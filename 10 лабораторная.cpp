#include <iostream>
#include <vector>

int main()
{
    /*за счет каких средств языка с++ получается изменять длину массива std::vector ?
    динамическое управление памятью - выделять помять, когда необходимо и копировать элементы*/

    /*Что такое capacity и чем оно отличается от size ? Что делает shrink_to_fit, resize, reserve ?
    capacity - определяет количество элементов, которое вектор может содержать без изменения своей структуры
    size - показывает текущее количество элементов.
    shrink_to_fit  - уменьшает емкость так, чтобы она соответствовала реальному размеру(capacity -> size)
    resize - оставляет в векторе n первых элементов. Если новый массив больше текущего, то будут добавлены новые элементы, а если меньше, 
    то удалены(инициализируются значением по умолчанию, либо resize(n, value) - вставляет value).
    reserve - резервирует память без добавления элементов.
    */

    /*Что обозначают знаки < и > при создании std::vector ?
    Парвметры шаблона, указывающий тип элементов, которые будут храниться в векторе */

    /* Продемонстрируйте работу push_back, erase, insert, clear.*/
    
    std::vector<int> v1{ 1, 2, 2, 3, 4, 5, 6, 7, 8, 9 };

    v1.reserve(20);
    std::cout << v1.capacity() << " " << v1.size() << std::endl;//20 10

    v1.resize(7);
    std::cout << v1.capacity() << " " << v1.size() << std::endl;//20 7


    v1.push_back(7);
    for (int n : v1) {
        std::cout << n << " ";//1 2 2 3 4 5 6 7
    }
    std::cout << std::endl;

    v1.erase(v1.begin() + 3);
    for (int n : v1) {
        std::cout << n << " ";//1 2 2 4 5 6 7
    }
    std::cout << std::endl;

    v1.insert(v1.begin() + 2, 3);
    for (int n : v1) {
        std::cout << n << " ";//1 2 3 2 4 5 6 7
    }
    std::cout << std::endl;

    v1.insert(v1.begin() + 2, 2, 4);
    for (int n : v1) {
        std::cout << n << " ";//1 2 4 4 3 2 4 5 6 7
    }
    std::cout << std::endl;

    v1.clear();
    for (int n : v1) {
        std::cout << n << " ";
    }
    std::cout << v1.capacity() << " " << v1.size() << std::endl;// 20 0

    v1.shrink_to_fit();
    std::cout << v1.capacity() << " " << v1.size() << std::endl;// 0 0


    /*  В чем отличие функции at и[] ? И почему в С++ сделали именно так ?
    Оператор, предоставляющий доступ к элементу по индексу (vector[3]), однако не проверяет на выход за пределы контейнера
    at() - делает то же самое, но также делает проверку допустимого диапозона(vector.at(3))
    Сделали так, потому что C++ стремится к балансу между производительностью и безопасностью([] - использовать, когда уверены в корректности,
    at - когда необходимо проверить доступ к элементам контейнера*/
}

